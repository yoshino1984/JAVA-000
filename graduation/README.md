# 简略总结系列

## JVM

- 学到了jvm基础知识、字节码、类加载机制、内存模型以及GC算法
- 其次这部分最有用的还是学到了命令行工具的使用方法，以前不习惯使用命令行，但是从各个情况下的GC调试日志作业开始也渐渐习惯了
- 同时也了解到了可量化可测量的重要性，没有可量化的前提，所做的优化就没有事实的检测证据。

后续方向：首先整理复习

## NIO

- 了解了一些基本的概念
    - 同步/异步
    - 阻塞/非阻塞
    - BIO、NIO、AIO
    - Reactor/Proactor
- 学到了Netty相关的知识，包括序列化编码、粘包半包等的优化方式等
    - 网络这部分知识后续需要继续学习
- 了解了业务网关和流量网关的区别\

后续方向：网络相关的内容、零拷贝等概念的澄清、netty源码

## 并发编程

- 澄清了基本的概念：线程及其生命周期、并发相关的性质
- 多线程：jdk中多线程的相关的类及其参数影响
- 并发：锁和并发工具类

后续方向：《Java 并发编程实战》、AQS源码分析

## 开放框架

- Spring技术体系：核心就是IOC和AOP 以及其他
- ORM体系：对于 JPA、Hibernate、Mybatis

后续方向：spring核心模块（IOC和AOP）的源码解读、找一个好用的Mybatis代码自动生成工具、Hibernate学习

## MySQL 数据库和 SQL

- 在这部分对关系型数据库的整个体系建立了个大概的轮廓了
    - 数据库的设计范式、典型的关系型数据库MySQL及相关的数据库表设计优化

    - SQL 的事务、锁、以及关系型数据库中的 log的作用

    - sql的执行优化、及一些相关问题


## 分库分表

- 单机MySQL数据库的容量、性能和可靠性无法满足日益膨胀需求，因此MySQL的高可用就需要一些其他的手段来保证

    - 主从复制来备份数据库，建立集群确保高可靠

    - 读写分离来分担查询性能

- 随着读写压力、高可用性、容量问题等进一步发展之后，就需要对数据库表进行拆分，来解决这些问题

    - 缺点：导致一致性问题

    - 方式：垂直拆分和水平拆分

- 框架：sharding-jdbc、mycat等



### 分布式事务

- 分布式数据库系统必然带来数据一致性问题，在有些需要确保高可靠的场景就有了引入分布式事务来进行解决的需求
- 两种实现理论
    - XA
        - 强一致性，性能差
        - 2PC
        - 框架：Atomikos、narayana、seata
    - BASE 柔性事务
        - 基本可用、柔性状态、最终一致性
        - TCC：try、confirm、cancel
    - AT：通过自动补偿处理
        - SAGA：没有 try阶段，直接提交事务，每个操作都有一个回滚动作，发生异常直接回滚
        - 框架：seata、 hmily



## RPC 和微服务

- RPC基本原理：核心是代理机制。封装对远程的调用，调用远程的方法就像是调用同一个jvm中的内部方法一样方便

    - 这一过程就涉及到了下述几个步骤

```
1.本地代理存根: Stub
2.本地序列化反序列化
3.网络通信
4.远程序列化反序列化
5.远程服务存根: Skeleton
6.调用实际业务服务
7.原路返回服务结果
8.返回给本地调用方
```

- 了解了 Dubbo 的架构及大致的处理流程及原理
- 分布式服务治理的需求解决催生了一系列的解决方案
    - 配置中心、注册中心、元数据中心：解决配置的即时热更新或者服务器的即时探知等问题
    - 服务的注册与发现
    - 服务的集群与路由
    - 服务的过滤与流控

- 还了解了微服务架构的发展历程：响应式微服务、服务网格与云原生、数据库网格、单元化架构
    - 因为也经历过拆分了很多微服务，最后又由于缺乏人手和回去的情况，对*微服务架构应该应用于大规模复杂业务系统中*这一点深有体会

### Spring Cloud技术体系

- Config/Eureka/Consul
- Zuul/Zuul2/Spring Cloud Gateway
- Feign/Ribbon
- Hytrix/Alibaba Sentinel

### 微服务相关框架与工具

- APM：应用性能监控，Apache Skywalking、Pinpoint、Zipkin、Jaeger

- 监控：ELK、promethus + Grafana、MQ + 时序数据库（influxDB/openTSDB等）

- 权限控制：CAS+SSO(TGT、ST)、JWT/Token OAuth2.0、SpringSecurity Apache Shiro

- 数据处理
- 网关与通信

    - 1、流量网关与WAF(Nginx/OR/Kong/Apisix)
    - 2、业务网关(Zuul/Zuul2/SCG/Soul)
    - 3、REST与其他协议之争（websocket/actor/rsocket/mq...）



后续：dubbo源码阅读、SpringCloud体系的了解、微服务架构各个组件的了解（应该是个长期的计划了）



## 分布式缓存

- 由于空间换时间在很多情况下都是划算的，并且很多数据也适合进行缓存，并且单机本地缓存存在缓存放大及损耗业务等缺点，远程的分布式缓存渐渐地成为一个可靠地选项

    - 适合缓存的数据：静态数据、准静态数据、中间状态数据；热数据、读写别较大的数据

    - 分布式缓存框架：

        - 缓存中间件：Redis/Memcached
        - 内存网格：Hazelcast/Ignite

    - 缓存策略和过期策略

    - 缓存常见问题和解决：缓存穿透、缓存击穿、缓存雪崩

- Redis

    - 基本功能：5种基本数据结构和3种高级数据结构都需要熟练掌握（特别是基础的）

    - 使用场景非常多：业务数据、缓存业务、数据处理、全局一致计数、高效统计计数、发布订阅与Stream、分布式锁

    - Java客户端：Jedis、Lettuce、Redission

    - 高级功能：事务、Lua脚本、备份与同步等

    - 高可用：主从复制、sentinel 主从切换、cluster走向分片



后续方向：Redis作为主要的研究目标：熟练使用、源码阅读、相关衍生的工具和框架熟悉



## 分布式消息队列

- mq的优点：削峰填谷、异步通信、发送和消费端系统解耦、可靠通信

- mq的消息模式主要分为两种：点对点、发布订阅模式

    - 消息处理时会遇到可靠性、事务性、有序性等问题

- 同时也了解了消息协议：JMS、AMQP、MQTT等

- 开源消息中间件/消息队列

    1. ActiveMQ/RabbitMQ（一代）
        1. 主要基于内存，不支持堆积
        2. 支持 queue 和 topic
        3. 支持 JMS 和 AMQP等
    2. Kafka/RocketMQ（二代：目前的主流）
        1. 引入磁盘，消息堆积的能力
        2. 只支持 topic
        3. 本身不支持 JMS 和 AMQP等

    3. Apache Pulsar（三代：未来）
        1. 存储和计算节点分离

后续方向：熟悉Kafka和RocketMQ、了解一代的mq的一些内容

## 总结

渐渐地四个月就过去了，总之就是学到了很多，极大的扩展了我的技术视野，见识了很多以前没听过的概念、工具、框架。经过了这段时间的学习，我对Java整个知识体系有了一个更清晰的轮廓概念和地图，后续就只要花时间填充和弄明白模糊的部分，吸收消化这部分的知识，相信应该能够更快更好地成长。

- 非常感谢秦老师、助教和老师们。